#version 430
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_shader_image_load_store : enable

struct TerrainCell {
	float height;
	vec3 normal_NW;
	vec3 normal_SE;
	float padding;
};

struct WaterParticle {
	vec3 position;	//  [0, terrain_size]
	vec3 velocity;
	float mass;
	float padding[1];
};

precision mediump float;

layout( location = 0 ) uniform uint delta;

layout(std430, binding = 1) coherent readonly buffer in_cells{
  WaterParticle particles_in[];
};

layout(std430, binding = 2) coherent buffer out_cells{
  WaterParticle particles_out[];
};

layout(std430, binding = 3) coherent readonly buffer terrain_data{
  TerrainCell terrain[];
};


layout(local_size_x = 30, local_size_y = 30, local_size_z = 1) in;

const int terrain_size = 3600;

//RainDrop controls "resolution" of the watershed. Higher Values == Fatter Rivers
const float rain_drop = .01;
//Determines something
const float ground_friction = .07;
const float gravity = -.098;
const float spawn_height = 5;

//MC controls speed, "viscosity" of flow
const float manning_coeff = 1.f;

highp float random(vec2 co)
{
    highp float a = 12.9898 + float(delta)*.1;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return abs(fract(sin(sn) * c));
}

uint get_terrain_index(uint x, uint y){
	return x + y*terrain_size;
}

void main() {
	uint index = gl_LocalInvocationIndex;

	WaterParticle particle = particles_in[index];
	uint rand_x = gl_GlobalInvocationID.x;
	uint rand_y = gl_GlobalInvocationID.y;
	
	if(particle.mass <= 0){
		//Make it rain_drop
		particle.mass = rain_drop * random(vec2(rand_x, rand_y));
		//Randomly position
		particle.position.x = terrain_size * random(vec2(rand_x + delta, rand_y + delta));
		particle.position.y = terrain_size * random(vec2(rand_x - delta, rand_y - delta));
		//Put it above the terrain
		particle.position.z = terrain[get_terrain_index(uint(particle.position.x), uint(particle.position.y))].height + spawn_height;

		//Reset velocity
		particle.velocity = vec3(0);
	}
	
	const TerrainCell ter_cell = terrain[get_terrain_index(uint(particle.position.x), uint(particle.position.y))];

	
	//Apply gravity + Move
		


	//Find terrain normal
	float normal_x = fract(particle.position.x);
	float normal_y = fract(particle.position.y);
	vec3 terrain_normal;
	if(normal_y > normal_x)
		terrain_normal = ter_cell.normal_NW;
	else
		terrain_normal = ter_cell.normal_SE;

	//Find height of terrain at particles position
	float terrain_at_position = 0;
	//terrain_at_position = 	


	//Check for collision
	if(particle.position.z <= terrain_at_position){
		

		float angle_of_incidence = acos(dot(normalize(particle.velocity), terrain_normal));

		//Collide
	}
		//Speed up/slowdown

	//Take off Evaporation

}
