#version 430
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_shader_image_load_store : enable

struct TerrainCell {
	float height;
};

struct WaterParticle {
	vec2 position;	//  [0, terrain_size]
	vec2 velocity;
	float mass;
};

precision mediump float;

layout( location = 0 ) uniform uint delta;

layout(std430, binding = 1) coherent readonly buffer terrain_data{
  TerrainCell terrain[];
};

layout(std430, binding = 1) coherent readonly buffer in_cells{
  WaterParticle particles_in[];
};

layout(std430, binding = 2) coherent buffer out_cells{
  WaterParticle particles_out[];
};

layout(local_size_x = 30, local_size_y = 30, local_size_z = 1) in;

const int terrain_size = 3600;

//RainDrop controls "resolution" of the watershed. Higher Values == Fatter Rivers
const float rain_drop = .01;
//Determines something
const float ground_friction = .07;
//MC controls speed, "viscosity" of flow
const float manning_coeff = 1.f;

highp float random(vec2 co)
{
    highp float a = 12.9898 + float(delta)*.1;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return abs(fract(sin(sn) * c));
}

uint get_terrain_index(uint x, uint y){
	return x + y*terrain_size;
}

void main() {
	uint index = gl_LocalInvocationIndex;

	WaterParticle particle = particles_in[index];
	uint rand_x = gl_GlobalInvocationID.x;
	uint rand_y = gl_GlobalInvocationID.y;


	if(particle.mass <= 0){
		//Make it rain_drop
		particle.mass = rain_drop * random(vec2(rand_x, rand_y));
		//Randomly position
		particle.position.x = terrain_size * random(vec2(rand_x + delta, rand_y + delta));
		particle.position.y = terrain_size * random(vec2(rand_x - delta, rand_y - delta));
		//Reset position
		particle.velocity = vec2(0);
	}
	
	vec2 pos = particle.position;
	vec2 target = vec2(pos.x + 

	int target_index = get_index(cellX + dX, cellY + dY);
	int star_index = get_index(cellX + sign(dY + dX), cellY + sign(dY - dX));
	int port_index = get_index(cellX + sign(dX - dY), cellY + sign(dY + dX));


	TerrainCell target = terrain[target_index];
	TerrainCell starboard = terrain[star_index];
	TerrainCell port = terrain[port_index];


	//Move
		//

		//Check for collision

		//Speed up/slowdown

	//Take off Evaporation

}
